// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: cinemas.sql

package storage

import (
	"context"

	"github.com/google/uuid"
	"github.com/pgvector/pgvector-go"
)

const createCinema = `-- name: CreateCinema :one
INSERT INTO cinemas (
    private, title, original_title,
    release_year, age_rating, duration_minutes,
    poster_url, description, genres,
    actors, rating, embedding
) VALUES (
        $1, $2, $3, $4, $5, $6,
        $7, $8, $9, $10, $11, $12
) RETURNING id
`

type CreateCinemaParams struct {
	Private         bool
	Title           string
	OriginalTitle   *string
	ReleaseYear     *int32
	AgeRating       *int32
	DurationMinutes *int32
	PosterUrl       *string
	Description     *string
	Genres          []string
	Actors          []string
	Rating          *float64
	Embedding       pgvector.Vector
}

func (q *Queries) CreateCinema(ctx context.Context, db DBTX, arg CreateCinemaParams) (uuid.UUID, error) {
	row := db.QueryRow(ctx, createCinema,
		arg.Private,
		arg.Title,
		arg.OriginalTitle,
		arg.ReleaseYear,
		arg.AgeRating,
		arg.DurationMinutes,
		arg.PosterUrl,
		arg.Description,
		arg.Genres,
		arg.Actors,
		arg.Rating,
		arg.Embedding,
	)
	var id uuid.UUID
	err := row.Scan(&id)
	return id, err
}

const deleteCinema = `-- name: DeleteCinema :exec
DELETE FROM cinemas WHERE id = $1
`

func (q *Queries) DeleteCinema(ctx context.Context, db DBTX, id uuid.UUID) error {
	_, err := db.Exec(ctx, deleteCinema, id)
	return err
}

const filmExists = `-- name: FilmExists :one
SELECT EXISTS(SELECT(1) FROM cinemas WHERE id = $1)
`

func (q *Queries) FilmExists(ctx context.Context, db DBTX, id uuid.UUID) (bool, error) {
	row := db.QueryRow(ctx, filmExists, id)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const getAllCinemas = `-- name: GetAllCinemas :many
SELECT id, private, title, original_title, release_year, age_rating, duration_minutes, poster_url, description, genres, actors, rating, embedding FROM cinemas
`

func (q *Queries) GetAllCinemas(ctx context.Context, db DBTX) ([]Cinema, error) {
	rows, err := db.Query(ctx, getAllCinemas)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Cinema
	for rows.Next() {
		var i Cinema
		if err := rows.Scan(
			&i.ID,
			&i.Private,
			&i.Title,
			&i.OriginalTitle,
			&i.ReleaseYear,
			&i.AgeRating,
			&i.DurationMinutes,
			&i.PosterUrl,
			&i.Description,
			&i.Genres,
			&i.Actors,
			&i.Rating,
			&i.Embedding,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCinemaByID = `-- name: GetCinemaByID :one
SELECT id, private, title, original_title, release_year, age_rating, duration_minutes, poster_url, description, genres, actors, rating, embedding FROM cinemas WHERE id = $1
`

func (q *Queries) GetCinemaByID(ctx context.Context, db DBTX, id uuid.UUID) (Cinema, error) {
	row := db.QueryRow(ctx, getCinemaByID, id)
	var i Cinema
	err := row.Scan(
		&i.ID,
		&i.Private,
		&i.Title,
		&i.OriginalTitle,
		&i.ReleaseYear,
		&i.AgeRating,
		&i.DurationMinutes,
		&i.PosterUrl,
		&i.Description,
		&i.Genres,
		&i.Actors,
		&i.Rating,
		&i.Embedding,
	)
	return i, err
}

const getCinemaPic = `-- name: GetCinemaPic :one
SELECT poster_url FROM cinemas
WHERE id = $1
`

func (q *Queries) GetCinemaPic(ctx context.Context, db DBTX, id uuid.UUID) (*string, error) {
	row := db.QueryRow(ctx, getCinemaPic, id)
	var poster_url *string
	err := row.Scan(&poster_url)
	return poster_url, err
}

const getFeed = `-- name: GetFeed :many
SELECT id, private, title, original_title, release_year, age_rating, duration_minutes, poster_url, description, genres, actors, rating, embedding FROM cinemas
WHERE private = False AND
NOT EXISTS(SELECT(1) FROM viewed WHERE viewed.cinema_id = cinemas.id AND viewed.subject_id = $3)
ORDER BY cinemas.embedding <=> $1 LIMIT $2
`

type GetFeedParams struct {
	Embedding pgvector.Vector
	Limit     int32
	SubjectID uuid.UUID
}

func (q *Queries) GetFeed(ctx context.Context, db DBTX, arg GetFeedParams) ([]Cinema, error) {
	rows, err := db.Query(ctx, getFeed, arg.Embedding, arg.Limit, arg.SubjectID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Cinema
	for rows.Next() {
		var i Cinema
		if err := rows.Scan(
			&i.ID,
			&i.Private,
			&i.Title,
			&i.OriginalTitle,
			&i.ReleaseYear,
			&i.AgeRating,
			&i.DurationMinutes,
			&i.PosterUrl,
			&i.Description,
			&i.Genres,
			&i.Actors,
			&i.Rating,
			&i.Embedding,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTopRated = `-- name: GetTopRated :many
SELECT id, private, title, original_title, release_year, age_rating, duration_minutes, poster_url, description, genres, actors, rating, embedding FROM cinemas
WHERE private = False
ORDER BY cinemas.rating DESC OFFSET $2 LIMIT $1
`

type GetTopRatedParams struct {
	Limit  int32
	Offset int32
}

func (q *Queries) GetTopRated(ctx context.Context, db DBTX, arg GetTopRatedParams) ([]Cinema, error) {
	rows, err := db.Query(ctx, getTopRated, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Cinema
	for rows.Next() {
		var i Cinema
		if err := rows.Scan(
			&i.ID,
			&i.Private,
			&i.Title,
			&i.OriginalTitle,
			&i.ReleaseYear,
			&i.AgeRating,
			&i.DurationMinutes,
			&i.PosterUrl,
			&i.Description,
			&i.Genres,
			&i.Actors,
			&i.Rating,
			&i.Embedding,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserModelByLogin = `-- name: GetUserModelByLogin :one
SELECT id, login, password, privileged, embedding, provider, yandex_id, access_token FROM users WHERE login = $1
`

func (q *Queries) GetUserModelByLogin(ctx context.Context, db DBTX, login string) (User, error) {
	row := db.QueryRow(ctx, getUserModelByLogin, login)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Login,
		&i.Password,
		&i.Privileged,
		&i.Embedding,
		&i.Provider,
		&i.YandexID,
		&i.AccessToken,
	)
	return i, err
}

const searchFilm = `-- name: SearchFilm :many
SELECT id, private, title, original_title, release_year, age_rating, duration_minutes, poster_url, description, genres, actors, rating, embedding FROM cinemas
WHERE private = False 
ORDER BY levenshtein(lower(cinemas.title), lower($1)) ASC
LIMIT 10
`

func (q *Queries) SearchFilm(ctx context.Context, db DBTX, lower string) ([]Cinema, error) {
	rows, err := db.Query(ctx, searchFilm, lower)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Cinema
	for rows.Next() {
		var i Cinema
		if err := rows.Scan(
			&i.ID,
			&i.Private,
			&i.Title,
			&i.OriginalTitle,
			&i.ReleaseYear,
			&i.AgeRating,
			&i.DurationMinutes,
			&i.PosterUrl,
			&i.Description,
			&i.Genres,
			&i.Actors,
			&i.Rating,
			&i.Embedding,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchFilmWitTags = `-- name: SearchFilmWitTags :many
SELECT id, private, title, original_title, release_year, age_rating, duration_minutes, poster_url, description, genres, actors, rating, embedding FROM cinemas
WHERE private = False 
AND genres @> $2
ORDER BY levenshtein(lower(cinemas.title), lower($1)) ASC
LIMIT 10
`

type SearchFilmWitTagsParams struct {
	Lower  string
	Genres []string
}

func (q *Queries) SearchFilmWitTags(ctx context.Context, db DBTX, arg SearchFilmWitTagsParams) ([]Cinema, error) {
	rows, err := db.Query(ctx, searchFilmWitTags, arg.Lower, arg.Genres)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Cinema
	for rows.Next() {
		var i Cinema
		if err := rows.Scan(
			&i.ID,
			&i.Private,
			&i.Title,
			&i.OriginalTitle,
			&i.ReleaseYear,
			&i.AgeRating,
			&i.DurationMinutes,
			&i.PosterUrl,
			&i.Description,
			&i.Genres,
			&i.Actors,
			&i.Rating,
			&i.Embedding,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchTagsOnly = `-- name: SearchTagsOnly :many
SELECT id, private, title, original_title, release_year, age_rating, duration_minutes, poster_url, description, genres, actors, rating, embedding FROM cinemas
WHERE genres @> $1
ORDER BY rating LIMIT 50
`

func (q *Queries) SearchTagsOnly(ctx context.Context, db DBTX, genres []string) ([]Cinema, error) {
	rows, err := db.Query(ctx, searchTagsOnly, genres)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Cinema
	for rows.Next() {
		var i Cinema
		if err := rows.Scan(
			&i.ID,
			&i.Private,
			&i.Title,
			&i.OriginalTitle,
			&i.ReleaseYear,
			&i.AgeRating,
			&i.DurationMinutes,
			&i.PosterUrl,
			&i.Description,
			&i.Genres,
			&i.Actors,
			&i.Rating,
			&i.Embedding,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const setCinemaPic = `-- name: SetCinemaPic :exec
UPDATE cinemas 
SET poster_url = $2
WHERE id = $1
`

type SetCinemaPicParams struct {
	ID        uuid.UUID
	PosterUrl *string
}

func (q *Queries) SetCinemaPic(ctx context.Context, db DBTX, arg SetCinemaPicParams) error {
	_, err := db.Exec(ctx, setCinemaPic, arg.ID, arg.PosterUrl)
	return err
}

const updateCinema = `-- name: UpdateCinema :exec
UPDATE cinemas SET 
    title = $1, original_title = $2,
    release_year = $3, age_rating = $4,
    duration_minutes = $5, poster_url = $6,
    description = $7, genres = $8,
    actors = $9, rating = $10
WHERE id = $11
`

type UpdateCinemaParams struct {
	Title           string
	OriginalTitle   *string
	ReleaseYear     *int32
	AgeRating       *int32
	DurationMinutes *int32
	PosterUrl       *string
	Description     *string
	Genres          []string
	Actors          []string
	Rating          *float64
	ID              uuid.UUID
}

func (q *Queries) UpdateCinema(ctx context.Context, db DBTX, arg UpdateCinemaParams) error {
	_, err := db.Exec(ctx, updateCinema,
		arg.Title,
		arg.OriginalTitle,
		arg.ReleaseYear,
		arg.AgeRating,
		arg.DurationMinutes,
		arg.PosterUrl,
		arg.Description,
		arg.Genres,
		arg.Actors,
		arg.Rating,
		arg.ID,
	)
	return err
}
